---
title: "Prónostico del nivel del TESLA"
author:
  - name: "Chávez Huapeo Jacqueline"
    affiliation: "2002159X"
    email: "2002159x@umich.mx"
  - name: "Flores Ochoa Sofia Libertad" 
    affiliation: "2209997A"
    email: "2209997a@umich.mx"
  - name: "Mendoza Esteban Lizzet"
    affiliation: "2111029D"
    email: "2111029d@umich.mx"
  - name: "López Carmona Audrey Carolina"
    affiliation: "2209983D"
    email: "2209983d@umich.mx"
  - name: "Rosas Moreno Alesi"
    affiliation: "2209988C"
    email: "2209988c@umich.mx"
format: pdf
---

# Introducción

El objetivo de este ejercicio es detrminar el mejor modelo $ARMA(P,Q)$ para pronosticar el nivel diario del IPC.

Se cargan las librerías necesiarias:

```{r}
# Liberías de yahoo finance de Github:
source("https://raw.githubusercontent.com/OscarVDelatorreTorres/yahooFinance/main/datosMultiplesYahooFinance.R")
# Librerías de cuantificación de riesgos en Github:
source("https://raw.githubusercontent.com/OscarVDelatorreTorres/riskManagementSuiteR/refs/heads/main/riskManagementSuiteFunctions.R")
# Librerías de uso general:
library(plotly)
library(dplyr)
library(tseries)
library(quantmod)
library(tidyverse)
library(tibble)
library(forecast)
library(DT)
```

Ahora descargamos los datos del IPC desde Yahoo Finance:

```{r}
# Ejemplo para descargar los históricos diarios de grupo Alfa (en moneda local), Microsoft en EEUU (convertido a MXN), Mercado Libre en EEUU (convertido a MXN) y el índice S&P/BMV IPC (en moneda local), desde el 1 de enero de 2023 a la fecha actual:
tickerV=c("TSLA")
deD=Sys.Date()-(3*365)
hastaD=Sys.Date()
per="D"
paridadFX="USDMXN=X"
convertirFX=c(TRUE)

Datos=historico_multiples_precios(tickers=tickerV,de=deD,hasta=hastaD,periodicidad=per,fxRate=paridadFX,whichToFX=convertirFX)
precios=Datos$tablaPrecios
rendimientos=Datos$tablaRendimientosCont
```

## Modelo ARIMA óptimo

Vemos los datos descargados:

```{r}
datatable(precios)
```

Veamos la gráfica del índice:

```{r}
fig1=plot_ly(data=precios,x=~Date,y=~TSLA,type="scatter",mode="lines"
)
fig1
```

La gráfica no dice mucho de si la serie de tiempo es estacionaria o no. Esto a efecto de saber si se trabaja con la variable a **nivel** ($P_t$) o con primeras diferencias (o primeras diferencias de logaritmos, léase rendimientos). Para esto, se hace la prueba de raíz unitaria Dickey-fuller aumentada:

```{r}
adf.test(precios$TSLA)
```

Como la prueba sugiere que la serie de tiempo del IPC es no estacionaria, entonces, se calcula la primera diferencia y se aplica la prueba de raíz unitaria a la transformación:

```{r}
PL=diff(precios$TSLA,1)
adf.test(PL)
```

Ahora hacemos lo propio pero con rendimientos y primeras diferencias logaítmicas:

```{r}
r=diff(log(precios$TSLA),1)
adf.test(r)
```

Comparemos las 3 gráficas

```{r}
precios$PL=c(0,PL)
precios$r=c(0,r)

fig2a=plot_ly()%>%add_trace(data=precios,x=~Date,y=~TSLA,
type="scatter",mode="lines",name="Precio")
fig2b=plot_ly()%>%add_trace(data=precios,x=~Date,y=~PL,
type="scatter",mode="lines",name="P/L")
fig2c=plot_ly()%>%add_trace(data=precios,x=~Date,y=~r,
type="scatter",mode="lines",name="Rendeimiento cont.")

fig2=subplot(fig2a,fig2b,fig2c,nrows=3)
fig2
```

Se decide trabajar con variaones porcentuales para determinar el mejor modelo ARMA:

```{r}
modeloARMA=auto.arima(log(precios$TSLA))
summary(modeloARMA)
```

Con esto, hago un pronóstico de t+1 a t+7 días:

```{r}
pronosticoTSLA=as.data.frame(forecast(modeloARMA,n=7))
pronosticoPuntual=pronosticoTSLA$`Point Forecast`
pronosticoPuntual=exp(pronosticoPuntual)
```

Ahora, buscaremos el mejor modelo de Red Neuronal Profunda (LSTM) para pronosticar los rendimientos logarítmicos y luego convertirlos a niveles de TSLA Realizaremos una búsqueda de hiperparámetros para el número de capas ocultas y el número de unidades (perceptrones) por capa.

# Cálculo de VaR y volatilidades de TESLA

## Volatilidad con suavizamiento exponencial

Ahora, siguiendo lo visto en el tema de [suavizamiento exponencial en el curso](https://oscarvdelatorretorres.github.io/materias/01Actuaria/03admonRiesgos/02ModelosDeVolatilidad/#/volatilidad-con-suavizamiento-exponencial-forma-en-sucesi%C3%B3n), calculamos la volatilidad de TESLA con suavizamiento exponencial, utilizando un factor de suavizamiento $\lambda = 0.95$:

```{r}
lambda1 <- 0.95
pesos=lambda1^(0: (nrow(rendimientos)-2))
varExp1=(1-lambda1)*sum(pesos*(rendimientos$TSLA^2))
varTimeFixed=var(rendimientos$TSLA)

cat("La volatilidad de TESLA con suavizamiento exponencial (lambda=0.95) es:", sqrt(varExp1), "%\n")
cat("La volatilidad de TESLA con varianza de tiempo fijo es:", sqrt(varTimeFixed), "%\n")
```

Ahora calculamos la siguiente volatilidad a $\lambda=0.98$ sobre el rendimiento diario de 1 año de BIMBOA y se estima el VaR al 98% de confianza, con una función de probabilidad gaussiana para una inversión o exposición a la acción de \$500,000.00:

```{r}
tickerV=c("TSLA")
deD=Sys.Date()-(3*365)
hastaD=Sys.Date()
per="D"
paridadFX="USDMXN=X"
convertirFX=c(TRUE)

Datos=historico_multiples_precios(tickers=tickerV,de=deD,hasta=hastaD,periodicidad=per,fxRate=paridadFX,whichToFX=convertirFX)
precios=Datos$tablaPrecios
rendimientos=Datos$tablaRendimientosCont
```

Se calcula la volatilidad con suavizamiento exponencial:

```{r}
lambda2 <- 0.98
pesos=lambda2^((1:(nrow(rendimientos))-1))
varExp2=(1-lambda2)*sum(pesos*(rendimientos$TSLA^2))
varTimeFixed=var(rendimientos$TSLA)

cat("La volatilidad de TESLA con suavizamiento exponencial (lambda=0.98) es:", sqrt(varExp1), "%\n")
cat("La volatilidad de TESLA con varianza de tiempo fijo es:", sqrt(varTimeFixed), "%\n")
```

Se calcula el VaR al 98% de confianza para una exposición de \$500,000.00:

```{r}
t=1  # horizonte de tiempo de un día
nivelConfianza <- 0.98
z_score <- qnorm(1-nivelConfianza)
M <- 500000
VaR_gaussiano <- M * abs(z_score) * (sqrt(varExp2)/100)*sqrt(t)
cat("El VaR gaussiano al 98% de confianza para una exposición de $500,000.00 es: $", formatC(VaR_gaussiano,format="f",big.mark=","), "\n")
```

## Volatilidad con modelo GARCH(1,1)

Ahora, estimamos la volatilidad de TESLA utilizando un modelo GARCH(1,1) gaussianamente distribuido:

```{r}
library(rugarch)
spec <- ugarchspec(variance.model = list(model = "sGARCH", 
                                         garchOrder = c(1, 1)),
                   mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
                   distribution.model = "norm")
garch_fit <- ugarchfit(spec = spec, data = rendimientos$TSLA)
```

```{r}
spec_tgarch <- ugarchspec(
  variance.model = list(model = "fGARCH", submodel = "TGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 0)),
  distribution.model = "norm"
)

fit_tgarch <- ugarchfit(spec = spec_tgarch, data = rendimientos$TSLA)
```

Veamos la tabla del modelo de GARCH (coeficientes, valores t, etc.):

```{r}

tabla_resultados <- garch_fit@fit$matcoef
tabla_resultados[, 1:3]
```

```{r}
# Mostrar resultados del modelo TGARCH
tabla_resultados_tgarch <- fit_tgarch@fit$matcoef
print("Resultados TGARCH(1,1):")
print(tabla_resultados_tgarch[, 1:3])
```

```{r}
# FUNCIÓN rollGARCH CORREGIDA - AGREGA ESTO ANTES
rollGARCH <- function(data, model = "sGARCH", submodel = NULL, LLF = "norm", 
                     garchOrder = c(1,1), ventana = 100, arma = c(0,0), 
                     include.mean = FALSE, upDown = TRUE, ...) {
  
  n <- length(data)
  volatilities <- rep(NA, n)
  
  for(i in (ventana+1):n) {
    window_data <- data[(i-ventana+1):i]
    
    # Manejar el parámetro submodel correctamente
    if(!is.null(submodel)) {
      spec <- ugarchspec(
        variance.model = list(model = model, submodel = submodel, garchOrder = garchOrder),
        mean.model = list(armaOrder = arma, include.mean = include.mean),
        distribution.model = LLF
      )
    } else {
      spec <- ugarchspec(
        variance.model = list(model = model, garchOrder = garchOrder),
        mean.model = list(armaOrder = arma, include.mean = include.mean),
        distribution.model = LLF
      )
    }
    
    # Ajustar modelo
    fit <- try(ugarchfit(spec = spec, data = window_data, solver = "hybrid"), silent = TRUE)
    
    if(!inherits(fit, "try-error")) {
      volatilities[i] <- tail(sigma(fit), 1)
    }
  }
  
  return(volatilities)
}

```

Para apreciar el comportamiento dinámico de la volatilidad estimada por el modelo GARCH(1,1), graficamos la varianza GARCH histórica, a partir de los últimos 150 datos de hoy hacia atrás.

```{r}
garchMovil = rollGARCH(rendimientos$TSLA, model = "sGARCH", LLF = "norm", garchOrder = c(1,1), ventana = 100, arma = c(0,0), include.mean = FALSE, upDown = TRUE)
suavExponMovil95 = rollEWSigma(rendimientos$TSLA, lambda = 0.95, ventana = 100)
suavExponMovil98 = rollEWSigma(rendimientos$TSLA, lambda = 0.98, ventana = 100)
garchMovil_TGARCH = rollGARCH(rendimientos$TSLA, model = "fGARCH", submodel = "TGARCH", LLF = "norm", garchOrder = c(1,1), ventana = 100, arma = c(0,0), include.mean = FALSE, upDown = TRUE)

tablaVolatilidades = data.frame(Fecha = rendimientos$Date,
    Volatilidad_GARCH = garchMovil,
    Volatilidad_TGARCH = garchMovil_TGARCH,
    Volatilidad_SE_95 = suavExponMovil95,
    Volatilidad_SE_98 = suavExponMovil98)
```

```{r}

 plot_ly() %>% 
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_GARCH,
            type = "scatter", mode = "lines", name = "Volatilidad GARCH(1,1)") %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_SE_95,
            type = "scatter", mode = "lines", name = "Volatilidad SE (λ=0.95)") %>%
 add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_SE_98,
            type = "scatter", mode = "lines", name = "Volatilidad SE (λ=0.98)") %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_TGARCH,
            type = "scatter", mode = "lines", name = "Volatilidad TGARCH(1,1)")
```

```{r}
V1 = plot_ly() %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_GARCH,
            type = "scatter", mode = "lines", name = "Volatilidad GARCH(1,1)")

V2 = plot_ly() %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_TGARCH,
            type = "scatter", mode = "lines", name = "Volatilidad TGARCH(1,1)")

V3 = plot_ly() %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_SE_95,
            type = "scatter", mode = "lines", name = "Volatilidad SE (λ=0.95)")

V4 = plot_ly() %>%
  add_trace(data = tablaVolatilidades, x = ~Fecha, y = ~Volatilidad_SE_98,
            type = "scatter", mode = "lines", name = "Volatilidad SE (λ=0.98)")

```

```{r}
fig3 <- subplot( fig2a, fig2b, fig2c,V1, V2, V3, V4,nrows = 7)

fig3 <- fig3 %>% layout(title = "Comparativo de Volatilidades para TESLA")
fig3

```

# MODELO T-GARCH

*T-GARCH (Threshold GARCH)* es un modelo de volatilidad que extiende el GARCH tradicional incorporando un efecto asimétrico lineal. Lo que significa que los choques negativos (malas noticias) tienen un impacto directo y más fuerte en la volatilidad que los positivos.

*Ecuación:*

$$\sigma_t^2 = \omega + \alpha |\varepsilon_{t-1}| + \gamma D_{t-1} |\varepsilon_{t-1}| + \beta \sigma_{t-1}^2$$ donde:

-   $D_{t-1}$ es una variable indicadora que vale 1 si el choque anterior fue negativo, y 0 si no lo fue.

-   $\gamma$ mide el efecto adicional de los choques negativos

-   $\alpha$ mide la sensibilidad a la magnitud del choque.

Partiendo de esto nos parecio una excelente opcion la acción de TESLA, ya que las acciones del sector tecnológico suelen reaccionar fuertemente a eventos negativos.

De manera particular en este caso TESLA suele reaccionar fuertemente de manera negativa a tweets de Elon Musk o a cambios regulatorios. Por ejmeplo, en la gráfica podemos observar que la volatibilidad en el modelo Garch se mantiene más estable, pues les da el mismo peso a los impactos positivos que a los impactos negativos. A comparación de la volatibilidad del modelo T-Garch que varía más por darle mayor peso a los eventos negativos, esto se ve claramente a principios de junio del 2025 donde hay eventos negativos, por eso difiere considerablemente la volatibilidad en el modelo Garch y el T-Garch (aumenta la volatibilidad).
